@startuml

title HTML puppeteer - Classes Diagram

abstract AbstractComponent {
  #config
  #dataAttributes
  #eventHandlersBound
  #eventsBinder
  #id
  #options
  #parent
  #stateInitializer
  #stateProcessor
  #$renderElem
  #partName
  #stateHolder
  #doWithState(stateUpdaterFn)
  +appendStateChangesHandlers(\nstateChangesHandlers)
  +close()
  +constructor(options)
  +disconnect()
  +getMutableState()
  +getStateCopy()
  +isStateEmpty(): boolean
  +render(value)
  +replaceFromParent()
  +replaceState(newState)
}

note left of AbstractComponent::config
constructor //options// + //dataAttributes//
end note

note left of AbstractComponent::options
constructor //options//
end note

note left of AbstractComponent::doWithState
Applies (using //stateUpdaterFn//)
the state changes then
passes the related events to
//StateChangesHandlersInvoker//.
end note

note left of AbstractComponent::"close()"
Clears the state
and //disconnect()//.
end note

note left of AbstractComponent::"disconnect()"
Detaches the DOM
event handlers.
end note

note left of AbstractComponent::"render(value)"
Attaches DOM event
handlers, initializes the
state using //value//
(if provided, otherwise
uses //stateInitializer//).
end note

class ChildrenCollection {
#children: {partName: AbstractComponent}
#childrenOptions
#childrenShellFinder: ChildrenShellFinder
#dontRender: boolean
#parent: AbstractComponent
+closeAndRemoveChild(partName)
+closeAndRemoveChildren()
+constructor(options)
+createChildrenForExistingShells()
+createOrUpdateChild(partName, $shell)
+disconnectAndRemoveChildren()
+getChildById(itemId)
+getChildByPartName(partName)
+updateFromParent(partName)
}

abstract EventsBinder {
  component: AbstractComponent
  +constructor(component)
  {abstract}+attachEventHandlers()
  {abstract}+detachEventHandlers()
}

note top of EventsBinder
  Contains handlers for DOM events.
  Usual handler processing:
  - capture only intended events
  (use business agnostic filters)
  - invoke suitable component methods
end note

abstract StateInitializer {
{abstract}+load(component)
}

class ValueStateInitializer extends StateInitializer {
    #value
    +constructor(value)
    +load(component)
}

class ChildStateInitializer extends ValueStateInitializer {
    +load(component)
}

class StateChange {
    #changeType: string
    #previousState
    #newState
    +constructor(\n\tpreviousStateOrPart, \n\tnewStateOrPart\n)
}

class PartStateChange extends StateChange {
    #newPart
    #newPartName
    #previousPart
    #previousPartName
    constructor(\n\tpreviousCompleteState,\n\tnewCompleteState,\n\tpreviousPart, newPart,\n\tpreviousPartName,\n\tnewPartName\n)
}

abstract StateChangeAugmenter {
    +augment(partStateChange)
}

class TypeStateChangeAugmenter extends StateChangeAugmenter {
    +augment(partStateChange)
}

abstract StateChangesCollector {
    #stateChanges
    #stateChangeAugmenter
    +constructor(stateChangeAugmenter)
    +collect(stateChange): StateChange
    +augment(stateChange): StateChange
    +consumeAll(): StateChange[]
}

abstract StateHolder {
    #currentState
    #config
    #stateChangesCollector
    #ignoreDuplicatedUpdates
    #mutableState
    #stateCopy
    +constructor({stateChangeAugmenter,\nstateChangesCollector, ...restOfOptions})
    +isEmpty(): boolean
    +replace(newState,\n[dontRecordChanges]): StateChange[]
}

/'note left of StateHolder::replace
Besides replacing the
state it'll also record
the changes using
//stateChangesCollector//.
end note'/

abstract PartialStateHolder extends StateHolder {
    +getPart(partName, [dontClone])
    +hasEmptyPart(partName): boolean
    +getParts(): {[key: string]: *}[]
    +replacePart(\npreviousPartName, \nnewPart, newPartName, \n[dontRecordChanges])
}

' note left of PartialStateHolder::replacePart
note bottom of PartialStateHolder
A null/undefined replacement
value should be treated as
"completelly remove the
associated objects" while
an empty object should be
treated as: the part's are
missing but the whole exists.
end note

class SimpleComponent extends AbstractComponent {
    +constructor({\n\tcomponentIllustratorProviders, \n\t...restOfOptions\n})
}

class ValueComponent extends SimpleComponent {
    +constructor({\n\tcomponentIllustratorProviders, \n\t...restOfOptions\n})
}

'SimpleComponent -[hidden]--> AbstractComponent

class ChildrenShellFinder {
    #$containerElem
    #containerIsComponent
    +constructor($containerElem)
    +$getAllChildrenShells()
    +$getChildShellsByPartName(partName)
}

class ContainerHelper {
    #component: AbstractComponent
    +constructor(component)
    +createContainerChildrenCommonOptions()
    +createChildrenShellFinder()
    +createChildrenCollection()
    +createShellCreator()
    +createShellsManager()
}

class AbstractContainerComponent extends AbstractComponent {
    #childrenCollection
    #childrenShellFinder
    #containerHelper
    #partialStateHolder
    +constructor(options)
    +getPart(partName, dontClone)
    +replacePart(previousPartName, newPart, \nnewPartName, dontRecordChanges)
    +replacePartByChildId(childId, newPart, \nnewPartName)
    +replaceParts(parts)
    +createChildrenForAllShells()
    +close()
    +disconnect()
}

AbstractContainerComponent *---- ChildrenCollection
AbstractContainerComponent *---- ChildrenShellFinder
AbstractContainerComponent *---- ContainerHelper
AbstractContainerComponent *--- PartialStateHolder

class StaticContainerComponent extends AbstractContainerComponent {
    #ignoreMissingShells
    +constructor(options)
    +replaceState(newState)
    +replacePart(previousPartName, newPart,\nnewPartName, dontRecordChanges)
}

class DynamicContainerComponent extends AbstractContainerComponent {
    #shellsManager
    +constructor(options)
    +replaceState(newState)
    +replacePart(previousPartName, newPart,\nnewPartName, dontRecordChanges)
}

class OnOffComponent extends AbstractContainerComponent {
    #activeNamesKey
    #activeNames
    +constructor(options)
    +replaceState(newState)
    +replacePart(previousPartName, newPart, \nnewPartName = previousPartName, \ndontRecordChanges)
    +switchTo(newActiveNames)
}

class SwitcherComponent extends AbstractContainerComponent {
    #activeNameKey
    #activeValueKey
    #valueKeyIsActiveName
    #activeComponent
    #activeName
    +constructor({\n\tcomponentIllustratorProviders, \n\t...restOfOptions\n})
    +replaceState(newState)
    +switchTo(activeName, \nignoreIfAlreadyActive = true)
    +replacePart(previousPartName, newPart, \nnewPartName = previousPartName, \ndontRecordChanges)
}

interface AbstractView {
    +create(value)
    +remove()
    +replace(value)
}

/'note right of AbstractView::create
Creates the DOM
element to contain
the //value// to display.
If //value// is not empty
calls //replace(value)//
to show them.
end note'/

/'note left of AbstractView::replace
Replaces the previous
displayed value with
the new ones.
end note'/

/'note right of AbstractView::remove
Removes the view's
DOM element.
end note'/

class SimpleView implements AbstractView {
    #$elem: jQuery<HTMLElement>
    #removedPlaceholder
    #viewRemovalStrategy: \n\tREMOVE_ELEMENT |\n\tREMOVE_CONTENT |\n\tUSE_HTML
    #viewRenderStrategy: \n\tRENDER_VAL |\n\tRENDER_TEXT |\n\tRENDER_HTML
    #viewValuesTransformer
    +constructor(options)
    +create(values)
    +remove()
    +replace(values)
}

class AbstractTemplateView extends SimpleView {
#htmlTemplate: string
+constructor({htmlTemplate,\ntemplateId, ...restOfOptions})
}

class SimpleTemplateView extends AbstractTemplateView {
    +remove()
    +replace(values)
}

class SwitcherView extends SimpleTemplateView {
    +switch(previousStatus, nextStatus)
}

class StateChangesHandlersInvoker {
    #handleAllChangesMethodName
    #handleAllPartChangesMethodName
    #partChangeMethodNamePrefix
    #stateChangesHandlers
    +constructor(options)
    +appendStateChangesHandlers(...stateChangesHandler)
    +processStateChanges(stateChangesCollector)
}

/'note left of StateChangesHandlersInvoker::handlerMappingRules
Defaults to:
- map state initialization
(aka creation) to
//created(stateChange)//
- map state modification
to //replaced(stateChange)//
- map state part (aka section)
modification to
//partReplaced(stateChange)//
- map state part removal to
//partRemoved(stateChange)//
end note'/

' note left of StateChangesHandlersInvoker::processStateChanges
note top of StateChangesHandlersInvoker
    Conveys state changes
    to the registered handlers.
end note

interface StateChangesHandler {
    +created(stateChange)
    +replaced(stateChange)
    +removed(stateChange)
    +changeOccurred(stateChange)
}

interface PartialStateChangesHandler extends StateChangesHandler {
    +partRemoved(stateChange)
    +partCreated(stateChange)
    +partRelocated(stateChange)
    +partReplaced(stateChange)
    +partChangeOccurred(stateChange)
}

class CopyStatesChangeHandler implements PartialStateChangesHandler {
    #receiverComponentFactory
    #receiverComponent
    +constructor({receiverComponent, \nreceiverComponentFactory})
    +changeOccurred(stateChange)
}

CopyStatesChangeHandler -[hidden]--> PartialStateChangesHandler

class ComponentIllustrator implements StateChangesHandler {
    #view: AbstractView
    +constructor({view, viewProviderFn, ...restOfOptions})
    +created(stateChange)
    +removed(stateChange)
    +replaced(stateChange)
}

note right of ComponentIllustrator
    //created//, //replaced//, //removed//
    methods delegate to the
    corresponding //view// methods.
    //changeOccurred// does nothing.
end note

class SwitcherIllustrator extends ComponentIllustrator implements PartialStateChangesHandler {
    #activeNameKey
    #switcherView
    +constructor({activeNameKey, viewProviderFn, ...restOfOptions})
    +partChangeOccurred(partStateChange)
}

class SimplePartsIllustrator extends ComponentIllustrator implements PartialStateChangesHandler {
    +constructor({viewValuesTransformer, ...restOfOptions})
    +partChangeOccurred(partStateChange)
}

note bottom of SimplePartsIllustrator
    By default will render
    (aka pass to //view//) the
    complete new state.
end note

AbstractComponent *-- EventsBinder
AbstractComponent *-- StateHolder
AbstractComponent *-- StateInitializer
'AbstractComponent *-down- DomValuesReader
'AbstractComponent *-down- ErrorsHandler
AbstractComponent *-- StateChangesHandlersInvoker
StateChangesHandlersInvoker "1" *-- "many" StateChangesHandler
ComponentIllustrator *--- AbstractView
StateHolder *-- StateChangesCollector
StateChangesCollector "1" *-- "many" StateChange
StateChangesCollector *-- StateChangeAugmenter

SwitcherComponent *-- SwitcherIllustrator
SimpleComponent *-- SimplePartsIllustrator

'StaticContainerComponent -[hidden]--> AbstractContainerComponent
'DynamicContainerComponent -[hidden]--> AbstractContainerComponent
OnOffComponent -[hidden]--> AbstractContainerComponent
SwitcherComponent -[hidden]--> AbstractContainerComponent

@enduml
