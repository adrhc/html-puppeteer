@startuml

title HTML puppeteer - Classes Diagram

abstract AbstractComponent {
  #stateHolder: PartialStateHolder
  #config:
  #eventsBinder
  #stateInitializer
  #domValuesReader
  #stateChangesHandlerAdapter
  #[initErrorsHandler]
  #doWithState(fn(partialStateHolder))
  +render(value)
  +close()
  +syncState()
  +getState()
  +replaceState(newState)
  +replacePart(previousPartName, \nnewPart, newPartName
}

note top of AbstractComponent
  Contains methods
  usually doing these:

  - receive a (DOM) event
  - analyze the event
  - change the state using
  <i>doWithState(fn(stateHolder))</i>

  State changing methods
  might use <i>syncState()</i>.
end note

/'note left of AbstractComponent::constructor
<i>config</i> parameter is used
to set/initialize any field.

If too complex <i>config</i> could
actually be a <i>configurer</i> class.

An important <i>config</i> attribute
is the component's DOM element
which usually will already exist.
end note'/

/'note left of AbstractComponent::domElement
Is the component's DOM element
which for parent/root components
will usually already exist.
Part owner components on the
other hand should be able to
create and identify it by only
using the state; e.g. dom
element's id could be <i>partName</i>.
end note'/

note left of AbstractComponent::doWithState
Applies (using <i>fn</i>)) the state
changes then passes
the related events to
<i>StateChangesHandlerAdapter</i>.
end note

note left of AbstractComponent::"render(value)"
Attaches DOM event
handlers, initializes the
state using <i>value</i>
(if provided, otherwise
uses <i>stateInitializer</i>)
and handles the state
loading errors.
end note

note left of AbstractComponent::"close()"
Clears the state
and detaches the
DOM event handlers
end note

note left of AbstractComponent::syncState
Synchronizes state with
its visual representation.
end note

note left of AbstractComponent::getState
Returns a state copy.
end note

/'abstract AbstractContainerComponent extends AbstractComponent {
  +create(partName, partValue)
  +remove(partName)
  +replace(partName, partValue)
  +move(partName, toPartName)
}'/

class SimpleContainerIllustrator extends SimplePartsIllustrator {
#childrenComponents: ChildrenComponents
#childrenShells: ChildrenShells
+created(stateChange)
+replaced(stateChange)
+partCreated(partStateChange)
+partRemoved(partStateChange)
+partReplaced(partStateChange)
+partRelocated(partStateChange)
+partChangeOccurred(partStateChange)
}

SimpleContainerIllustrator -> ChildrenComponents
SimpleContainerIllustrator *- ChildrenShells

class ChildrenShells {
#$containerElem
#parentId
#place: "append" | "prepend"
#shellTemplate
#setPartOwnerAndIdToShellTemplate(partOwnerAndId)
#createShell(partName)
+getOrCreateShell(partName)
+removeShell(partName)
}

class ChildrenComponents {
#elemIdOrJQuery
#items: {partName: AbstractComponent}
#parent: AbstractComponent
+createItem(partName)
+updateFromParent(itemName)
+removeItem(partName)
+getItemById(itemId)
}

abstract EventsBinder {
  component: AbstractComponent
  {abstract}+attachEventHandlers()
  {abstract}+detachEventHandlers()
}

note bottom of EventsBinder
  Contains handlers for DOM events.
  Usual handler processing:
  - capture only intended events
  (use business agnostic filters)
  - invoke suitable component methods
end note

abstract StateInitializer {
+load(component)
}

note bottom of StateInitializer
sets component's state
(from e.g. a repository)
end note

class ValueStateInitializer extends StateInitializer {
#value
+load(component)
}

class StateChange {
#changeType
#previousState
#newState
}

class PartStateChange extends StateChange {
#previousPartName
#previousPart
#newPartName
#newPart
}

'interface StateChangeEnhancer<T extends StateChange> {
interface StateChangeEnhancer {
+enhance(stateChange): T
}

interface StateChangesCollector {
#stateChanges
#stateChangeEnhancer
+collect(stateChange)
+collect(stateChanges)
+consumeOne(): StateChange
+consumeAll(): StateChange[]
}

interface StateHolder {
+get()
+replace(newState, \n[dontRecordChanges])
#stateChangesCollector
}

/'note left of StateHolder::replace
Besides replacing the
state it'll also record
the changes using
<i>stateChangesCollector</i>.
end note'/

interface PartialStateHolder extends StateHolder {
+getPart(partName)
+replacePart(\npreviousPartName, \nnewPart, \nnewPartName, \n[dontRecordChanges])
}

' note left of PartialStateHolder::replacePart
note bottom of PartialStateHolder
A null/undefined replacement
value should be treated as
"completelly remove the
associated objects" while
an empty object should be
treated as "use empty for
all part's fields".
end note

class SimpleContainerComponent extends AbstractComponent {
#childrenComponents: ChildrenComponents
#stateChangesHandlersInvoker=[SimpleContainerIllustrator]
+replaceState(newState)
+getItemById(itemId): AbstractComponent
#replaceContainerStateOnly(newState)
}

SimpleContainerComponent *- ChildrenComponents

interface ErrorsHandler {
+accept(error)
}

interface AbstractView {
+create(value)
+replace(value)
+remove()
}

/'note right of AbstractView::create
Creates the DOM
element to contain
the <i>value</i> to display.
If <i>value</i> is not empty
calls <i>replace(value)</i>
to show them.
end note'/

/'note left of AbstractView::replace
Replaces the previous
displayed value with
the new ones.
end note'/

/'note right of AbstractView::remove
Removes the view's
DOM element.
end note'/

class SimpleView implements AbstractView {
#$elem: jQuery<HTMLElement>
#removedPlaceholder
#viewRemovalStrategy: \n\tREMOVE_ELEMENT |\n\tREMOVE_CONTENT |\n\tUSE_HTML
+create(values)
+replace(values)
+remove()
}

class AbstractTemplateView extends SimpleView {
#htmlTemplate: string
#viewRemovalStrategy: \n\tREMOVE_ELEMENT |\n\tREMOVE_CONTENT |\n\tUSE_HTML |\n\tUSE_THE_TEMPLATE
#_createTemplate(templateId)
}

class SimpleTemplateView extends AbstractTemplateView {
+replace(values)
+remove()
}

class StateChangesHandlerAdapter {
stateChangesHandlers
+addHandler(stateChangesHandler)
+processStateChanges(stateChanges)
}

/'note left of StateChangesHandlerAdapter::handlerMappingRules
Defaults to:
- map state initialization
(aka creation) to
<i>created(stateChange)</i>
- map state modification
to <i>replaced(stateChange)</i>
- map state part (aka section)
modification to
<i>partReplaced(stateChange)</i>
- map state part removal to
<i>partRemoved(stateChange)</i>
end note'/

' note left of StateChangesHandlerAdapter::processStateChanges
note top of StateChangesHandlerAdapter
Conveys state changes
to the suitable handlers.
end note

interface StateChangesHandler {
+created(stateChange)
+replaced(stateChange)
+removed(stateChange)
+changeOccurred(stateChange)
}

interface PartialStateChangesHandler extends StateChangesHandler {
+partCreated(stateChange)
+partReplaced(stateChange)
+partRelocated(stateChange)
+partRemoved(stateChange)
+partChangeOccurred(stateChange)
}

abstract ComponentIllustrator implements StateChangesHandler {
view: AbstractView
}

note top of ComponentIllustrator
<i>created</i>, <i>replaced</i>, <i>removed</i>
delegate to corresponding
<i>view</i> methods.
<i>changeOccurred</i> does nothing.
end note

class SimplePartsIllustrator extends ComponentIllustrator implements PartialStateChangesHandler {
+partChangeOccurred(stateChange)
}

note left of SimplePartsIllustrator
By default will render
(aka pass to <i>view</i>) the
complete new state.
end note

/'abstract PartsAllocator implements PartialStateChangesHandler {
parts: Map<partName, AbstractComponent>
stateSynchronizer
#createNewOwners(stateChange)
#removeMissingOwners(stateChange)
#{abstract}createOwner(partName, part)
}

note top of PartsAllocator
Contains methods usually doing these:
- analyze the state changes
- manage the state parts owners
end note

note left of PartsAllocator::createNewOwners
- iterates the state parts
- creates new part owning components
- calls <i>newOwner.render(part)</i>
end note

note left of PartsAllocator::removeMissingOwners
- iterates the state parts
- closes then removes
  the <i>parts</i> no longer
  found in iterator
end note

class StateSynchronizer {
  #stateHolder
  #domValuesReader
  #partOwners: Map<partName, AbstractComponent>
  +syncState()
  +viewUpdated(view)
  +partOwnersUpdated(partOwners)
  #syncStateWithView()
  #syncStateWithPartOwners()
}

note left of StateSynchronizer::syncState
Updates (silently) the
state using view's value
and part owners state.
end note

note left of StateSynchronizer::syncStateWithPartOwners
It'll call <i>syncState()</i> on
part owners components
before reading their state.
end note'/

abstract DomValuesReader {
  view: AbstractView
  {abstract}+extractDomValues()
}

AbstractComponent *-down- EventsBinder
AbstractComponent *-down- StateHolder
AbstractComponent *-down- StateInitializer
AbstractComponent *-down- DomValuesReader
AbstractComponent *-down- ErrorsHandler
AbstractComponent *-up- StateChangesHandlerAdapter
StateChangesHandlerAdapter *-up- "many" StateChangesHandler
ComponentIllustrator *-- AbstractView
StateHolder *-- StateChangesCollector
StateChangesCollector *-- "many" StateChange
StateChangesCollector *-- StateChangeEnhancer

@enduml
